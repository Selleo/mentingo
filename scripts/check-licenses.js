const fs = require('fs');

function exitWithError(message, error) {
  console.error(`::error::${message}`);
  if (error) {
    console.error(error instanceof Error ? error.message : error);
  }
  process.exit(1);
}

function parseJson(envValue, errorMessage) {
  try {
    return JSON.parse(envValue);
  } catch (error) {
    exitWithError(errorMessage, error);
  }
}

const allowedLicensesEnv = process.env.ALLOWED_LICENSES_JSON;
if (!allowedLicensesEnv) {
  exitWithError('No allowed licenses loaded from licenses.config.json');
}

const allowedLicenses = parseJson(
  allowedLicensesEnv,
  'Failed to parse ALLOWED_LICENSES_JSON'
);

if (!Array.isArray(allowedLicenses) || allowedLicenses.length === 0) {
  exitWithError('Allowed licenses list is empty or invalid');
}

const allowedLicenseSet = new Set(allowedLicenses);
const allowedPackagesArray = parseJson(
  process.env.ALLOWED_PACKAGES_JSON || '[]',
  'Failed to parse ALLOWED_PACKAGES_JSON'
);

const allowedPackages = new Map();
for (const entry of allowedPackagesArray) {
  if (typeof entry !== 'string') continue;
  const at = entry.lastIndexOf('@');
  if (at <= 0 || at === entry.length - 1) continue;
  const name = entry.slice(0, at);
  const version = entry.slice(at + 1);
  if (!allowedPackages.has(name)) {
    allowedPackages.set(name, new Set());
  }
  allowedPackages.get(name).add(version);
}

const isPackageAllowed = (name, version) =>
  allowedPackages.get(name)?.has(version) === true;

const licensesPath = '/tmp/licenses.json';
let licensesJson;
try {
  licensesJson = fs.readFileSync(licensesPath, 'utf8');
} catch (error) {
  exitWithError(`Unable to read licenses file at ${licensesPath}`, error);
}

let licenses;
try {
  licenses = JSON.parse(licensesJson);
} catch (error) {
  exitWithError('Failed to parse licenses JSON generated by pnpm', error);
}

// Simple SPDX-expression parser for AND/OR + parentheses
function tokenize(expr) {
  return expr
    .split(/(\(|\)|\bAND\b|\bOR\b)/)
    .map((part) => part.trim())
    .filter(Boolean);
}

function parseExpression(tokens) {
  let pos = 0;

  function parseFactor() {
    const token = tokens[pos++];
    if (token === '(') {
      const node = parseOr();
      if (tokens[pos++] !== ')') throw new Error('Unexpected token, expected )');
      return node;
    }
    if (!token) throw new Error('Unexpected end of expression');
    return { type: 'license', id: token };
  }

  function parseAnd() {
    let left = parseFactor();
    while (tokens[pos] === 'AND') {
      pos++;
      left = { type: 'and', left, right: parseFactor() };
    }
    return left;
  }

  function parseOr() {
    let left = parseAnd();
    while (tokens[pos] === 'OR') {
      pos++;
      left = { type: 'or', left, right: parseAnd() };
    }
    return left;
  }

  const tree = parseOr();
  if (pos !== tokens.length) throw new Error('Unexpected trailing tokens');
  return tree;
}

function evalTree(node) {
  switch (node.type) {
    case 'license':
      return allowedLicenseSet.has(node.id);
    case 'and':
      return evalTree(node.left) && evalTree(node.right);
    case 'or':
      return evalTree(node.left) || evalTree(node.right);
    default:
      return false;
  }
}

function isAllowed(expr) {
  try {
    const tokens = tokenize(expr);
    if (tokens.length === 0) return false;
    const tree = parseExpression(tokens);
    return evalTree(tree);
  } catch {
    return false;
  }
}

const disallowedExpressions = new Set();
const disallowedPackages = [];
for (const [expr, packages] of Object.entries(licenses)) {
  const exprAllowed = isAllowed(expr);
  for (const pkg of packages) {
    const versions = pkg.versions ?? ['*'];
    const violatingVersions = versions.filter(
      (version) => !(exprAllowed || isPackageAllowed(pkg.name, version))
    );
    if (violatingVersions.length === 0) continue;
    disallowedExpressions.add(expr);
    violatingVersions.forEach((version) =>
      disallowedPackages.push(` - ${pkg.name}@${version}: ${expr}`)
    );
  }
}

if (disallowedPackages.length) {
  console.log('::error::Disallowed or unknown licenses detected:');
  Array.from(disallowedExpressions)
    .sort((a, b) => a.localeCompare(b))
    .forEach((expr) => console.log(expr));
  console.log();

  console.log('Dependencies using disallowed licenses:');
  disallowedPackages
    .sort((a, b) => a.localeCompare(b))
    .forEach((line) => console.log(line));
  process.exit(1);
}

console.log('âœ… All licenses are allowed.');
